# 12.重载新的方法（parent::）

在学习PHP 这种语言中你会发现， PHP中的方法是不能重载的， 所谓的方法重载就是定义相同的方法名，通过“**参数的个数**“不同或“**参数的类型**“不 同,来访问我们的相同方法名的不同方法。但是因为PHP是弱类型的语言， 所以在方法的参数中本身就可以接收不同类型的数据，又因为PHP的方法可以接收不定个数的参数，所以通过传递不同个数的参数调用不相同方法名的不同方法也是不成立的。所以在PHP里面没有方法重载。**不能重载也就是在你的项目中不能定义相同方法名的方法**。另外，因为PHP没有名子空间的概念，在同一个页面和被包含的页面中不能定义相同名称的方法， 也不能定义和PHP给我提供的方法的方法重名，当然**在同一个类中也不能定义相同名称的方法**。

我们这里所指的重载新的方法所指的是什么呢？其实我们所说的重载新的方法就是子类覆盖父类的已有的方法，那为什么要这么做呢？父类的方法不是可以继承过 来直接用吗？但有一些情况是我们必须要覆盖的，比如说我们前面提到过的例子里面， “Person”这个人类里面有一个“说话”的方法，所有继承“Person”类的子类都是可以“说话”的， 我们“Student”类就是“Person”类的子类，所以“Student”的实例就可以“说话“了， 但是人类里面“说话”的方法里面说出的是“Person”类里面的属性， 而“Student”类对“Person”类进行了扩展，又扩展出了几个新的属性，如果使用继承过来的“say\(\)”说话方法的话，只能说出从 “Person”类继承过来的那些属性，那么新扩展的那些属性使用这个继承过来的“say\(\)”的方法就说不出来了，那有的人就问了，我在 “Student”这个子类中再定义一个新的方法用于说话，说出子类里面所有的属性不就行了吗？一定不要这么做， 从抽象的角度来讲， 一个“学生”不能有两种“说话”的方法，就算你定义了两个不同的说话的方法，可以实现你想要的功能，被继承过来的那个“说话“方法可能没有机会用到了，而且是继承过来的你也删不掉。这个时候我们就要用到覆盖了。

虽然说在PHP里面不能定义同名的方法， 但是在父子关系的两个类中，我们可以在子类中定义和父类同名的方法，这样就把父类中继承过来的方法覆盖掉了。

```php
<?php
// 定义一个"人"类做为父类
class Person {
    // 下面是人的成员属性
    private $name;      // 人的名子
    private $sex;       // 人的性别
    private $age;       // 人的年龄
 
    // 定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值
    function __construct($name, $sex, $age) {
        $this->name = $name;
        $this->sex = $sex;
        $this->age = $age;
    }
 
    // 这个人可以说话的方法, 说出自己的属性
    function say() {
        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age;
    }
}
 
class Student extends Person {
    var $school; // 学生所在学校的属性
 
    // 这个学生学习的方法
    function study() {
        echo "我的名子叫：" . $this->name . " 我正在" . $this->school . " 学习";
    }
 
    // 这个学性可以说话的方法, 说出自己所有的属性，覆盖了父类的同名方法
    function say() {
        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age . " 我在" . $this->school . "上学";
    }
}
?>
```



